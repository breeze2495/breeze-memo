







## 二叉树:



### P1: 二叉树前/中/后序 递归 与 非递归遍历  

`leetcode: No.144,94,145`



#### D1: 递归解法简单

#### D2: 非递归(迭代)

<img src="/Users/breeze/Library/Application Support/typora-user-images/image-20210513145955238.png" alt="image-20210513145955238" style="zoom:69%;float:left" />

- **前序遍历**

顺序: 根 -> 左 -> 右

前序遍历在遍历时,是尽可能的往左下走,发现走不下去了,就往上弹一个

```java
public list<Integer> preorderTraversal(TreeNode root){
  List<Integer> res = new ArrayList<>();
  Deque<TreeNode> stack = new ArrayDeque<>();
  
  //核心代码start: *********************************
  while(root != null || !stack.isEmpty()){
  	 //往左下遍历
     while(root != null){
		 	 res.add(root.val);
       stack.push(root);
       root = root.left;
     }	
    
     //当达到了叶子节点,此时栈顶的节点就是当前叶子节点的父节点,将遍历的root节点指向为该栈顶节点的右子节点 
     TreeNode cur = stack.pop();
     root = cur.right;
	}
  //核心代码end:***************************************
  
  return res;
}
```



- **后序遍历**

顺序: 左 -> 右 -> 根

可以看做 reverse  根 -> 右 -> 左

**后序遍历:**根 -> 右 -> 左  与 **前序遍历:**的 根 -> 左 -> 右 有异曲同工之处 ,只需将代码稍作改变(代码中的左右互换)

```java
public list<Integer> preorderTraversal(TreeNode root){
  List<Integer> res = new ArrayList<>();
  Deque<TreeNode> stack = new ArrayDeque<>();
  
  //核心代码start: *********************************
  while(root != null || !stack.isEmpty()){
    
     while(root != null){
		 	 res.add(root.val);
       stack.push(root);
       root = root.right;
     }	
    
     TreeNode cur = stack.pop();
     root = cur.left;
	}
  //核心代码end:***************************************
 
  Collections.reverse(res);
  return res;
}
```



- **中序遍历**

顺序:  左 -> 根 -> 右

```java
public list<Integer> preorderTraversal(TreeNode root){
  List<Integer> res = new ArrayList<>();
  Deque<TreeNode> stack = new ArrayDeque<>();
  
  //核心代码start: *********************************
  while(root != null || !stack.isEmpty()){
    
     while(root != null){
       stack.push(root);
       root = root.left;
     }	
    	
     //一直往坐下走到叶子节点,并指向并弹出当前叶子节点,该节点就是需要添加进结果集中的元素
     root = stack.pop();
     res.add(root.val);
		 root = root.right;
	}
  //核心代码end:***************************************
 
  return res;
}
```









## 补充:



### P1: ArrayDeque类

#### D1: 概述

`ArrayDeque`是`Deque`接口的一个实现，使用了可变数组，所以没有容量上的限制。

同时，`ArrayDeque`是线程不安全的，在没有外部同步的情况下，不能再多线程环境下使用。

`ArrayDeque`是`Deque`的实现类，可以作为栈来使用，效率高于`Stack`；

也可以作为队列来使用，效率高于`LinkedList`。

需要注意的是，`ArrayDeque`不支持`null`值。



#### D2: API

```java
1.添加元素
        addFirst(E e)在数组前面添加元素
        addLast(E e)在数组后面添加元素
        offerFirst(E e) 在数组前面添加元素，并返回是否添加成功
        offerLast(E e) 在数组后天添加元素，并返回是否添加成功

  2.删除元素
        removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常
        pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null
        removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常
        pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null
        removeFirstOccurrence(Object o) 删除第一次出现的指定元素
        removeLastOccurrence(Object o) 删除最后一次出现的指定元素
   

   3.获取元素
        getFirst() 获取第一个元素,如果没有将抛出异常
        getLast() 获取最后一个元素，如果没有将抛出异常
   

    4.队列操作
        add(E e) 在队列尾部添加一个元素
        offer(E e) 在队列尾部添加一个元素，并返回是否成功
        remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())
        poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())
        element() 获取第一个元素，如果没有将抛出异常
        peek() 获取第一个元素，如果返回null
      

    5.栈操作
        push(E e) 栈顶添加一个元素
        pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常
        

    6.其他
        size() 获取队列中元素个数
        isEmpty() 判断队列是否为空
        iterator() 迭代器，从前向后迭代
        descendingIterator() 迭代器，从后向前迭代
        contain(Object o) 判断队列中是否存在该元素
        toArray() 转成数组
        clear() 清空队列
        clone() 克隆(复制)一个新的队列
```

















