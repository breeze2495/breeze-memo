### 第一章：绪论

- **逻辑结构**：线性；非线性：树，图；集合
- **存储（物理）结构**：顺序，链式，索引，散列

- **逻辑结构，存储结构和运算之间的关系**
  - 数据的逻辑结构反映数据元素之间的来了逻辑关系，与存储结构无关。
  - 数据的存储结构是数据在计算机中的表示。
  - 数据的运算是对数据定义的一组操作，运算是定义在逻辑结构上的，与存储结构无关，而运算的实现依赖于存储结构。



- **线性结构特征**：唯一第一，唯一最后，唯一前驱，唯一后继
- **什么是算法：**由基本运算以及规定的运算顺序所构成的完整的解题步骤；
- **算法特性**：有穷性，确定性，输入，输出，可行性





1.算法原地工作是指所需的辅助空间是常量；

2.连续存储设计时，存储单元的地址一定连续；

3.数据结构式带有结构的数据元素的集合；

4.算法分析通常指对算法实施事前分析；

5.算法的健壮性是指，当输入不合法数据时，程序会采取应急措施；也即容错性；



### 第二章：线性表

- **线性表是具有n个相同特性数据元素的有限序列，可以为空**

- **顺序表**：
  - 随机访问特性
  - 占用连续的存储空间（需要预先分配）
- **链表**：
  - 不支持随机访问
  - 结点的存储空间利用率稍低
  - 存储空间支持预先分配，连续与否均可以
- **静态链表**：
  - 指针指示的是下一元素在数组中的地址
  - 与顺序表相比：优点是便于插入和删除
  - 需要分配较大的连续空间，插入和删除不需要移动元素



1.将两个有n个元素的有序表归并成一个有序表，最少比较n次，最多比较2n-1次；

2.两个长度为n的单链表：循环链表和非循环链表占用的内存空间一样，非循环终端结点也有指针

3.进行连续存储分配时，存储单元地址一定连续

4.运算实现是针对存储结构的指出运算的具体操作步骤；运算定义是针对逻辑结构的。







### 第三章：栈和队列

- 出栈可能性： N=（1/（n+1））C2n n；
- 栈的应用：递归调用，子程序调用，表达式求值
- 

1.栈和队都是限制存取点的线性结构





### 第四章：串

- 定义：有零个或者多个字符组成的有限序列，限定了数据元素为一个字符的线性表





### 第五章：数组，矩阵和广义表



1.存取数组中任何一个元素所需的时间是相同的。

2.稀疏矩阵压缩存储后，必会失去随机存取功能；

3.对稀疏矩阵压缩的目的，减少不必要的存储空间；



### 第六章：树与二叉树

- **树的存储结构**

  - 顺序存储结构：树的双亲存储结构（需要会画）
  - 链式存储结构
    - 孩子存储结构：实质是图的领结表存储结构
    - 孩子兄弟存储结构：与树和森林的相互转换关系密切

- **二叉树**

  - 性质：

    - 非空二叉树叶子结点数等于双分支结点数加1； **n0=n2+1**；

      - 总结点数：n0+n1+n2 ； 总分枝数：n1+2n2；  n0+n1+n2 = n1+2n2+1；

      - 二叉树中中的结点数为n,则树中空指针个数可看作是二叉树的叶子结点，共n+1个

      - 度为m的树中，度为1的结点数为n1，度为2的结点数为n2，度为m的结点数为nm，

        则叶子结点数为**n0=1+n2+2n3+...+（m-1）nm**；

    - 给定n个结点，可以构成（1/（n+1））C2n n种不同的二叉树

    - 具有n（n>=1）个结点的完全二叉树高度为 （log2n）下取+1 或者  （log2（n+1））上取

- **线索二叉树**--为了加快查找结点的前驱或后继的速度

  - 线索二叉树是一种物理结构。
  - **高效**体现在：二叉树被线索化之后近似于一个**线性结构**，分支结构的遍历操作就转化为了近似于线性结构的遍历操作，通过线索的辅助使得**寻找结点的前驱或者后继**平均效率大大提高。
  - 会画线索二叉树（记得null指针也需要画出来）


- **树和森林与二叉树的相互转换**

  - 目的：一般树在满足树的条件下可以是任意形状的，一个节点可以有任意多个子女，二叉树的每个节点却最多只能有两个子女，即是左子女和右子女，显然一般树处理起来要复杂的多，所以将一般树转化成二叉树以便于操作。

- **树和森林的遍历**
  
- 先序遍历对应二叉树的先序， 后序遍历对应二叉树的中序
  
- **赫夫曼树（最优二叉树）与赫夫曼编码**

  - **带权路径长度**：结点具有权值，从该结点到根结点之间的路径长度乘以结点的权值。

  - **树的带权路径长度（wpl)**：树中所有叶子结点的带权路径长度之和。

  - **特点**： 

    - 权值越大的结点，距离根结点越近；
    - 树中没有度为1的结点，又称为正则（严格）二叉树；
    - 树的带权路径最短；
    - **一般判断一串码是不是赫夫曼**
      - 判断是否为前缀码
      - 是否有度为1的结点

  - **掌握赫夫曼树的构造方法**（构造出的树不唯一，一般使左子树根权值小于右子树根权值）

    - 当发现赫夫曼n叉树无法构造时，需要补0

  - **用途**：常见的.zip压缩文件和.jepg图片文件底层技术用到的就是赫夫曼编码。

  - **前缀码**：从根通往任一叶子结点的路径都不可能是通往其余叶子结点路径的子路径，

    ​			  赫夫曼编码产生的是最短前缀码。

1.会画树的双亲存储结构 p133

2.一棵二叉树的先序和后序遍历序列正好相反，则该二叉树一定是高度等于其结点数。

​	**非空二叉树先序和后序相反：只有一个叶子节点；**

​	**非空二叉树先序和后序相同：只有一个节点：**

3.二叉链表存储二叉树，要交换分支结点左右结点位置，利用后序遍历方法更合适。

4.先序，中序，后序遍历中，叶子结点在遍历序列中的先后顺序完全相同。

5.n个结点的线索二叉树上含有的线索数为： 2n-（n-1） =  n+1

6.森林，树，二叉树三者间的联系与区别：

​		森林是树的结合，二叉树是特殊的树。

​		二叉树与树的区别：	一是二叉树的度至多为2，树无此限制；

​											   二是二叉树有左右子树之分，即使只有一个分支的情况下，也必须指明是左还是右；

​											   三是二叉树允许为空，树一般不允许为空；

7.树，森林转换成二叉树的目的

​		

​												

### 第七章：图

- **图的基本概念**

  - **完全图**：n个顶点

    - 具有n（n-1）条边的有向图称为有向完全图
    - 具有n（n-1）/2条边的无向图称为无向完全图

  - **简单路径**：除了开始点和结束点可以相同以外，其余顶点均不相同，则称这条路径为简单路径。

  - **在无向图中**

    - 顶点Vi 到Vj有路径，称为**连通**
    - 图的任意两个顶点之间连通，称为**连通图**；否则图中的**极大连通子图**称为**连通分量**

  - **有向图中**

    - vi到vj有路径，称vi到vj连通。
    - 对于每对顶点，vi到vj，vj到vi都有路径，该图称为强连通图；否则，其中的极大强连通子图称为强连通分量

  - 边上带有权的图称为带权图，也称为网。

    

- **图的存储结构**
  - **邻接矩阵**：顺序存储结构 （掌握画法）
    - 无权图：自身用0，没有路径时用0，有路径时用1；
    - 有权图：自身用0，有路径用权值，没有路径用∞；
    - 无向图的邻接矩阵是对称矩阵
  - **领接表**：链式存储结构 （掌握画法）

- **图的遍历算法** 两者时间复杂度都为O（n+e）
  
  - **深度优先遍历算法DFS**
    - 类似于图的先序遍历
    - 当DFS应用于一个连通图时，所经历的边形成一棵树：
      - 由DFS可知，图中每个顶点都分别访问有且仅有一次，从一个顶点到另一个顶点必须经过这两个顶点的边，这样DFS就把连通图的全部顶点都访问了，共经过n-1条边，刚好使图联通，即为树。
  - **广度优先遍历算法BFS**
  - 对于无权图，可以用BFS来求最短路径问题；当各边的权值均相等时，BFS算法可用来解决单源最短路径问题：因为当权值相等时，最短路径问题就转化为了求边数最少的问题， BFS可以保证求得源点到汇点的最少边数。
    - 类似于图的层次遍历
  
- **最小（代价）生成树**

  - **定义**
    - 由n个顶点构成的边的权值之和最小的连通子图 
  - **普里姆**
    - 时间复杂度：**o（n2）**，只与图中顶点有关系，与边数没关系，适用于稠密图
  - **克鲁斯卡尔**
    - 时间复杂度：**o（elog2e）**，由边数决定，与顶点无关，适用于稀疏图
  - 两者都针对于无向图
  - 什么样的图最小生成树**唯一**？所有边的权值都不相同，或者有相等的边，但是在构造最小生成树的过程中，权值相等的边都被并入生成树的图

  

- **最短路径**

  - **迪杰斯特拉**：某一顶点到其余各顶点的最短路径；**o（n2）**
  - **弗洛伊德**：任意一对顶点间的最短路径； **o（n3）**

- **拓扑排序**

  - **AOV(activity on vertex)**：以顶点表示活动，以边表示活动的先后次序且没有回路的有向图。

  - 当有向图无环时，可以采用深度优先搜索遍历的方法进行拓扑排序。由于图中无环，当由图中某顶点出发进行DFS时，最先退出算法的顶点即为出度为0的点。它是拓扑有序序列中的最后一个顶点。因此，顶点退出系统栈的顺序即为逆拓扑排序。

  - **时间复杂度**：**o（n+e）**

  - 当一个有向图的邻接矩阵中主对角线以下的元素均为零，则该图拓扑有序序列一定存在：

    - 主对角线以下元素均为零时，代表图中只有由编号小的顶点指向编号大的顶点的边。

  - 若一个有向图中的顶点不能排成一个拓扑序列，则断定该有向图：含有顶点数目大于1的强连通分量。

    注意：不一定是强连通图，因为顶点数为1的图也是强连通图

  

- **关键路径**
- AOE 与 AOV
    - 相同点：都是有向无环图
    - 不同点：
      - aoe：边有权值，边代表活动持续时间；顶点代表时间。
      - aov：顶点表示活动，边无权值
  - 路径：由相邻顶点序偶所形成的序列
  - 关键路径定义：源点到汇点的最长路径，同时又代表工期完成的最短时间。
  - 求关键路径步骤
    1. 求**ve（k）：**顶点k的事件的最早发生时间。   **拓扑排序**，ve（0）=0；取**max{ , }**;
    2. 求**vl（k）：**事件k的最迟发生时间，事件k的最迟发生时间是在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。   **逆拓扑排序**的第一个顶点等于自身的ve，  取**min{ , };**
    3. 求**e（ak）：**活动ak的最迟发生时间：用ve求e（ak），e即是这个活动所**继承**的事件的ve；
    4. 求**l（ak）：**活动ak的最迟发生时间：**所达事件的vl减去活动的权值**；
    5. **关键活动：**活动的最早和最晚发生时间相等的ak；
- 活动的**剩余时间**：活动的最迟减最早发生时间，关键活动的剩余时间为0；
  - 一个工程的完成并不仅仅需要执行关键活动，所有活动都要执行，只不过关键路径执行所需的时间就是整个图中所有活动所完成的时间。
  - 关键活动延期，必将导致关键路径长度增加，即整个工期的最短完成时间增加。
  - 关键活动并不唯一，当有多条关键路径存在时，其中一条关键路径上的关键活动时间缩短，只会影响该条关键路径变成非关键路径，而无法缩短整个工期，因为其他路径没有变化。因此，某些关键活动的提前完成可能使整个工程提前完成；所有关键活动提前完成，那么整个工程将会提前完成。



​	

### 第八章：排序

- **堆排序**
  - 插入结点：将要插入的结点x放在最底层的最右边，插入后进行调整
  - 删除结点：删除堆中的某个结点，该结点的位置就会出现一个空，将最底层最右边的叶子的值赋给该空，并下调至合适位置，最后把该叶子结点删除。
  - 排序： 已经建立好了一个大顶堆，将堆顶关键字和序列的最下最右的元素a调换，堆顶元素到达最终位置，将除堆顶元素之外的元素进行第二趟排序，此时只有元素a是不满足堆的定义是，只需调整元素a。





### 第九章：查找

- **折半查找法**（**序号之和/2下取，从0开始**）

  - **表必须有序**，且只能以**顺序存储**方式存储；

  - 并不要求是递增或者递减有序，只要根结点能讲树中结点分为两部分即可；

  - 对关键字的数据类型没有规定；

  - 最坏情况下的比较次数为：log2n下取+1（用于做题，查找不成功时带入计算）； 

     时间复杂度：O(log2n);
     
  - 考：折半查找判定树，求ASL。

- **B-树与B+树**
  
  - **B-树**
    - 关键字个数n（除根结点）的取值范围:  m/2上取-1<=n<=m-1;根结点取值范围1<=n<=m-1;
    - b-树是平衡m叉查找树，但是限制更强，要求所有叶结点在同一层。
    - 求任意一颗包含n（n>=1)个关键字阶数为m的B-树的最大高度为hmax和最小高度为hmin；
  - **B+树**
    - 具有n个关键字的结点含有n个分支；
    - 关键字个数n（除根结点）的取值范围:  m/2上取<=n<=m;根结点取值范围2<=n<=m;
    - 叶子结点包含信息，并且包含了全部关键字；
    - 所有非叶子结点仅起到一个索引的作用，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址，而在b-树中，每个关键字对应一个记录的存储地址。
    - 有一个指针指向关键字最小的叶子结点，所有叶子结点链接成一个线性链表，而b-树没有。
  - **B-与B+的比较**
    - 两者都是平衡多叉树
    - 都可用于文件的索引结构
    - B+树所有的叶子结点包含了全部的关键字信息，且叶子结点本身依照关键字的大小自小而大顺序连接，可以进行顺序查找，而B+树不可以；
    - B-树的叶子结点不包含关键字，b+树包含；
  - 高度为h的m叉搜索树最多有m^h-1个元素。
- **二叉排序树与平衡二叉树**
  - **二叉排序树**（又称二叉搜索树）
    - 二叉排序树的查找效率取决于其高度，对于结点个数相同的二叉排序树，平衡二叉树 的高度最小，因此查找效率最高。
  - **平衡二叉树**（又称AVL树）
    - ⭐️ 用Nh表示高度为h的平衡二叉树中含有的最少结点数：
      - N0 = 0; N1 = 1; Nh =Nh-1 + Nh-2 + 1 ；
      - 此时所有非叶结点的平衡因子均为1， 
    - 平衡因子：左减右
- **散列表**（优点：均分布，平均查找长度最小）
  - hash查找法的时间复杂度为o（1）；
  - 堆积现象不可以被完全避免，链地址法也不可以。





1.不是所有的递归程序都需要用到栈，比方说求阶乘的，是单向递归，直接用循环去替代从1乘到n就是结果了，另外一些需要栈保存的也可以用队列等来替代的

2.中序遍历一棵二叉搜索树，可得到有序序列，时间复杂度为o（n）

3.

























