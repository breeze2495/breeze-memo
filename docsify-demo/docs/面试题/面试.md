#  JAVASE

### 	p1: 自增变量

```java
 public static void main(String[] args) {
        int i = 1;
        i = i++; //操作一
        int j = i++; //操作二
        int k = i + ++i * i++; //操作三
        System.out.println("i=" + i);
        System.out.println("j=" + j);
        System.out.println("k=" + k);
    }

//操作一
1.把i的值1压入操作数栈,此时局部变量表中的i值为1
2.i变量自增1,此时局部变量表中的i值为2
3.把操作数栈中的值1,赋值给i
4.结果i=1
  
//操作二
  j=1,此时i=2
  
//操作三
1.把i的值压入操作数栈 栈中为2
2.i变量自增 局部变量i=3 栈中为2
3.把i的值压入栈 操作数栈底到栈顶为: 2 3 
4.把i的值压入栈 操作数栈底到栈顶为: 2 3 3
5.i变量自增 局部变量i=4
6.操作数栈顶俩数乘法运算得9压入栈 操作数栈底到栈顶为: 2 9
7.再求和得最终结果:11
  
//最终结果
  i=4
  j=1
  k=14

```

- 赋值操作"=",最后计算;
- "="右边的从左到右加载值依次压入操作数栈;
- 实际先算哪个,看运算符优先级;
- 自增,自减操作都是直接修改变量的值,不经过操作数栈;
- 在最后赋值之前,临时结果也是存储在操作数栈中;



### P2: 类初始化 / 实例初始化

```java
public class Father {
    private int i = test();
    private static int j = method();

    static{
        System.out.println("(1)");
    }
    Father() {
        System.out.println("(2)");
    }
    {
        System.out.println("(3)");
    }
    public int test(){
        System.out.println("(4)");
        return 1;
    }
    public static int method() {
        System.out.println("(5)");
        return 1;
    }
}
————————————————
public class Son extends Father {
    private int i = test();
    private static int j = method();
    static {
        System.out.println("(6)");
    }
    Son() {
        super();
        System.out.println("(7)");
    }
    {
        System.out.println("(8)");
    }
    public int test(){
        System.out.println("(9)");
        return 1;
    }
    public static int method() {
        System.out.println("(10)");
        return 1;
    }

    public static void main(String[] args) {
        Son son = new Son();
        System.out.println();
        Son son1 = new Son();
    }
}

//执行结果: 5 1 10 6  |  9 3 2 9 8 7 | 9 3 2 9 8 7
```

- **类初始化:**
  -  一个类要创建实例需要先加载并初始化该类
  - man方法所在的类需要先加载和初始化
  - 一个子类的初始化需要先初始化父类
  - <clinit>方法
    - .java文件在编译后会在字节码文件中生成clinit方法,该方法被称为类构造器
    - 一个类初始化就是执行<clinit>方法
    - <clinit>方法由静态变量显示赋值代码 ( 代码中的j = method() ) 和静态代码块组成,从上至下执行
    - <clinit>方法只执行一次
- **实例初始化:**
  - <init>方法
    - .java文件在编译后会在字节码中生成<init>方法,该方法被称为实例构造器
    - 实例初始化就是执行<init>方法
    - <init>方法可能重载有多个,有几个构造器就有几个<init>方法
    - <init>方法由非静态显示赋值代码和非静态代码块,对应构造器组成,前两者按顺序从上至下执行,对应构造器最后执行
    - 每次创建实例对象,调用对应构造器,执行的就是<init>方法(每创建一次,执行一次)
    - <init>方法首行是super()和super(实参列表),即对应的父类<init>
- **注意:**
  - 子类中重写了父类的test()方法,因此都是执行子类中的test()
  - 而父类与子类中的都存在method()方法,子类不能重写父类的静态方法
    - **重写:**
      - 不能重写的方法:
        - final
        - 静态
        - private子类中不可见的方法



### P3:方法的参数传递机制

```java
public class Exam4 {
    public static void main(String[] args) {
        int i = 1;
        String str = "hello";
        Integer num = 200;
        int[] arr = {1,2,3,4,5};
        MyData my = new MyData();

        change(i,str,num,arr,my);

      	System.out.println("i= " + i);
        System.out.println("str= " + str);
        System.out.println("num= " + num);
        System.out.println("arr= " + Arrays.toString(arr));
        System.out.println("my.a= " + my.a);

    }
    public static void change(int j, String s, Integer n, int[] a, MyData m) {
        j += 1;
        s += "world";
        n += 1;
        a[0] += 1;
        m.a += 1;
    }
}
class MyData {
    int a = 10;
}

//输出结果
//1  hello  200  [2,2,3,4,5]  11
```

- **形参是基本数据类型:**
  - 传递数据值
- **形参是引用数据类型:**
  - 传递地址值
  - 特殊的类型:String,包装类等不可变性
- 具体见下图:

<img src="/Users/breeze/Library/Application Support/typora-user-images/image-20210312201650859.png" alt="image-20210312201650859" style="zoom: 33%;" />

















