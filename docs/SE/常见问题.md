###   D1: java.lang.OutOfMemoryError

- **原因:**
  - 内存中加载的数据过于庞大,例如从数据库中取了过多数据;
  - 集合类中有对对象的引用,使用完后未清空,使得JVM不能回收;
  - 代码中存在死循环或循环产生过多的重复的对象实体;
  - 启动参数内存值设定的过小;
  - 加载太多资源到内存,导致GC耗时太多;
- **解决:**
  - 



### D2: 接口和抽象方法的联系和区别

​		**接口是对动作的抽象,抽象类是对根源的抽象**

​		**抽象类主要是用来抽象类别，接口主要是用来抽象方法功能。**

​		当你关注事物的本质的时候，请用抽象类；当你关注一种操作的时候，用接口。

- 对于抽象类:男人,女人两个类,可以设计一个更高级别的抽象类--人;

- 对于接口:我们可以坐着吃饭,站着吃饭,用筷子吃饭,用勺子吃饭,可以把吃饭抽象成一个接口--**吃饭**

  

   所以像JAVA这样的高级语言,一个类只能继承一个抽象类(不可能既是人又是别的生物),

   但一个类可以同时实现多个接口,比如上班接口,开车接口,运动接口.

- **总结:**
  - 抽象类和接口都不能被直接实例化.如果要实例化,就涉及到多态. 
    - 如果抽象类要实例化,那么抽象类定义的变量必须指向一个子类对象,这个来自类继承了这个抽象类并实现了这个抽象类的所有抽象方法;
    - 如果接口要实例化,那么这个接口定义的变量要指向一个子类对象,这个子类必须实现了这个接口所有的方法;
  - 抽象类被子类继承,接口被子类实现;
  - 接口只能对方进行声明,抽象类既可以对方法进行声明也可以对方法进行实现;
  - 抽象类里面的抽象方法必须全部被子类实现，如果子类不能全部实现，那么子类必须也是抽象类。接口里面的方法也必须全部被子类实现，如果子类不能实现那么子类必须是抽象类。
  - 接口里面的方法只能声明，不能有具体的实现。这说明**接口是设计的结果，抽象类是重构的结果**。
  - 抽象类里面可以没有抽象方法;
  - 如果一个类里面有抽象方法，那么这个类一定是抽象类。
  - 抽象类中的方法都要被实现，所以抽象方法不能是静态的static，也不能是私有的private。
  - 接口可以继承接口，甚至可以继承多个接口。但是类只能继承一个类。
  - 抽象级别（从高到低）：接口>抽象类>实现类。
  - 抽象类主要是用来抽象类别，接口主要是用来抽象方法功能。当你关注事物的本质的时候，请用抽象类；当你关注一种操作的时候，用接口。
  - 抽象类的功能应该要远多于接口,但是定义抽象类的代价较高.因为高级语言一个类只能继承一个父类,即在设计这个类的时候必须要抽象出所有这个类的子类所具有的共同属性和方法;但是接口可以继承多个接口,因此每个接口只需要将特定动作方法抽象到这个接口即可.也就是说,接口的设计具有更大的可扩展性,而抽象类的设计需要谨慎;





### D3: private 和 final

在多线程的学习中

<img src="/Users/breeze/Library/Application Support/typora-user-images/image-20210512154605794.png" alt="image-20210512154605794" style="zoom:50%;float:left" />

子类继承父类,并重写了其中某一个方法, 在该方法中创建了一个新的线程操作了某个list,会出现线程安全问题

这也是private 和 final 提供的安全意义所在, 这也是开闭原则中的 "闭"













